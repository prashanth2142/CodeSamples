<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title></title>
    <style>
        body {
            font-family: 'Verdana', sans-serif;
            font-size: 18px;
            font-style: normal;
            font-weight: 400;
            line-height: 2;
            margin-left: 10%;
            margin-right: 10%;
        }

        .custom-font {
            font-family: 'Courier New', monospace;
            font-style: italic;
            font-weight: bold;
        }

        pre {
            background-color: #f4f4f4;
            padding: 20px;
            border-radius: 5px;
            font-family: Consolas, monospace;
            font-size: 16px;
            color: #333;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow: auto;
        }

        code {
            color: #d6336c;
        }
    </style>
</head>
<body>
    <p> 1. What is IL ( Intermediate Language) Code ?</p>
    <p>
        Intermediate Language (IL) code, also known as Microsoft Intermediate Language (MSIL) or Common Intermediate Language (CIL), is a low-level, platform-independent programming language. It is a key part of the .NET framework and serves as an intermediate step between the code written in high-level languages like C# and the machine code executed by the processor.
        How IL Works:

        Compilation:
        When you write code in C#, it is compiled by the C# compiler (csc.exe) into IL code.
        The resulting output is a DLL or EXE file, which contains IL along with metadata describing the program's structure (types, members, etc.).

        Just-In-Time (JIT) Compilation:
        At runtime, the IL code is compiled into native machine code by the Just-In-Time (JIT) compiler provided by the Common Language Runtime (CLR).
        This native code is then executed by the processor.

        Platform Independence:
        Because IL is platform-independent, the same compiled assembly can run on any platform where the .NET runtime is supported.

        Key Features of IL:

        Stack-based architecture: IL is designed as a stack-based language, where operations are performed on a virtual stack.
        Object-oriented: IL supports concepts like inheritance, polymorphism, and exception handling.
        Rich instruction set: IL includes instructions for loading, storing, arithmetic operations, method calls, branching, etc.
        Strong typing: IL is strongly typed, ensuring type safety and enabling features like garbage collection and runtime type checking.
    </p>
    <p> 2. What is CLR? </p>
    <p>
        The **Common Language Runtime (CLR)** is the core runtime environment in the .NET framework. It serves as the execution engine for .NET applications, providing services such as memory management, type safety, exception handling, and garbage collection. The CLR is responsible for managing the execution of code written in any .NET-supported language.

        ### Key Responsibilities of CLR:

        1. **Just-In-Time (JIT) Compilation**:
        - When you compile your C# code, it gets converted into Intermediate Language (IL) code. At runtime, the CLR's JIT compiler translates this IL code into native machine code specific to the operating system and hardware.

        2. **Memory Management**:
        - The CLR manages memory allocation and deallocation for .NET applications.
        - It includes an automatic **Garbage Collector (GC)** to reclaim memory occupied by objects no longer in use.

        3. **Type Safety**:
        - Ensures that code adheres to strict type rules, preventing operations that could lead to memory corruption or unpredictable behavior.

        4. **Code Execution**:
        - The CLR loads assemblies, performs runtime type checking, and ensures secure execution of the code.

        5. **Security**:
        - Provides mechanisms such as Code Access Security (CAS) and role-based security to protect against unauthorized code execution.

        6. **Exception Handling**:
        - Offers a consistent framework for error and exception handling across different .NET languages.

        7. **Interoperability**:
        - Facilitates interaction between .NET code and unmanaged code (e.g., native C++ libraries or Windows API calls).

        8. **Multithreading**:
        - Provides support for multithreaded applications and synchronization.

        ---

        ### How CLR Works:

        1. **Compilation Process**:
        - High-level code (C#, VB.NET, etc.) → **Intermediate Language (IL)** → **Machine Code** (via JIT at runtime).

        2. **Execution**:
        - When a .NET application starts, the CLR initializes, loads required assemblies, and compiles IL to native code. This code is executed by the CPU.

        3. **Managed vs. Unmanaged Code**:
        - Code executed under the control of the CLR is called **managed code**.
        - Code that runs outside the CLR (e.g., native C++) is referred to as **unmanaged code**.

        ---

        ### CLR Features:
        - **Cross-Language Interoperability**: Enables the use of multiple languages (e.g., C#, F#, VB.NET) in a single application.
        - **Portability**: Provides platform independence, allowing .NET applications to run on different operating systems using the same IL.
        - **Extensibility**: Supports the addition of custom libraries and runtime extensions.
        - **Debugging Support**: Works with tools like Visual Studio for efficient debugging and profiling.

        ---

        ### Benefits of CLR:
        1. Simplifies development by managing low-level programming tasks (e.g., memory allocation).
        2. Increases application reliability and security.
        3. Promotes code reusability and modular design through managed libraries.
        4. Provides a rich runtime environment for rapid application development.

        Would you like to explore specific aspects, like how CLR handles JIT or garbage collection?
    </p>
    <p> 3. What is the use of JIT ( Just in time compiler) ? </p>
    <p>
        The Just-In-Time (JIT) Compiler is a crucial component of modern runtime environments, such as the .NET Common Language Runtime (CLR) or the Java Virtual Machine (JVM). Its primary purpose is to improve the execution performance of applications by converting intermediate code into machine code at runtime. Here's a detailed explanation of its use:
        Key Uses of JIT Compiler:

        Dynamic Translation:
        JIT converts Intermediate Language (IL) or bytecode into native machine code just before execution.
        For example, in .NET, the C# code is first compiled into CIL (Common Intermediate Language), which is then JIT-compiled into machine code when the application runs.

        Improved Performance:
        By compiling code to native machine code, JIT can optimize execution based on the specific hardware and runtime conditions.
        Native machine code is faster to execute than interpreting bytecode directly.

        Platform Independence:
        Allows applications to run on different platforms without recompilation. The intermediate code is platform-independent, and the JIT compiler generates machine-specific code at runtime.

        Runtime Optimizations:
        JIT can apply optimizations that are only possible during execution, such as:
        Inlining: Replacing a function call with its code to avoid the overhead of calling functions.
        Loop unrolling: Improving the performance of loops.
        Dead code elimination: Removing unused or unnecessary code paths.

        Memory Efficiency:
        JIT compiles only the portions of code that are needed during execution, reducing the overall memory footprint compared to precompiling the entire application.

        Security:
        JIT compilers can enforce security checks, such as verifying type safety and access permissions, before translating intermediate code to native machine code.

        Support for Managed Code:
        In managed environments like .NET or Java, the JIT compiler works with the garbage collector and other runtime services to ensure the application runs safely and efficiently.
    </p>
    <p> 4.  What is the importance of CTS and CLS ?</p>
    <p>
        Common Language Specification (CLS)

        Purpose:
        The CLS defines a set of rules and constraints that all .NET languages must follow to ensure interoperability. It specifies the features that are common across all .NET languages, making it possible for components written in one language to be used in another.

        Importance:

        Language Interoperability: Ensures that different languages on the .NET platform can work together seamlessly. For instance, a class written in C# can be consumed by a VB.NET program.
        Subset of Features: Only includes features that are common and can be supported by all .NET languages. For example, certain advanced C# features (like pointers in unsafe code) may not be CLS-compliant.
        Cross-language Reusability: Allows developers to create libraries that can be used across multiple .NET languages.

        Common Type System (CTS)

        Purpose:
        The CTS standardizes how data types are defined, used, and managed in the .NET framework. It ensures that types in different languages are compatible and can interact with each other.

        Importance:

        Type Consistency: Provides a unified type system that ensures all .NET languages use the same underlying type definitions (e.g., int in C# and Integer in VB.NET are both mapped to System.Int32).
        Enables Code Sharing: Facilitates the sharing of code and data structures across languages by standardizing types.
        Standardized Data Types: Avoids confusion by ensuring that, for example, an int in one language is the same as an int in another.

        CTS has two categories of types:

        Value Types: Types that are stored on the stack (e.g., int, float, bool).
        Reference Types: Types that are stored on the heap (e.g., class, object, string).

        <table>
            <thead>
                <tr>
                    <th>
                        <strong>Feature</strong>
                    </th>
                    <th>
                        <strong>CLS</strong>
                    </th>
                    <th>
                        <strong>CTS</strong>
                    </th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>
                        <strong>Definition</strong>
                    </td>
                    <td>A set of rules for language interoperability.</td>
                    <td>A specification for defining and managing data types.</td>
                </tr>
                <tr>
                    <td>
                        <strong>Focus</strong>
                    </td>
                    <td>Common features across .NET languages.</td>
                    <td>Consistency in data types across .NET languages.</td>
                </tr>
                <tr>
                    <td>
                        <strong>Primary Benefit</strong>
                    </td>
                    <td>Enables cross-language integration.</td>
                    <td>Ensures type compatibility.</td>
                </tr>
            </tbody>
        </table>

    </p>
    <p> 5. Difference between Stack vs Heap ?</p>
    <p>
        Stack:

        Definition: Stack is a region of memory used for storing value types and references to objects in the heap.

        Key Features:
        Managed Memory: Automatically managed by the system. Memory is allocated and deallocated in a Last In, First Out (LIFO) manner.
        Storage: Holds:
        Local variables (value types).
        References to objects in the heap (when dealing with reference types).
        Scope-Limited: Memory allocated on the stack is freed once the method or block of code completes execution.
        Performance: Fast access due to its LIFO nature.
        Size Limitation: Stack has a fixed size, determined at the start of the program. Exceeding this size can cause a StackOverflowException.


        void Example() {
        int x = 10; // Stored on the stack (value type)
        }

        Heap is a region of memory used for dynamically allocated memory, typically for objects and data structures that need to persist beyond a single method call.

        Key Features:

        Managed Memory: Garbage Collector (GC) automatically handles memory allocation and deallocation.
        Storage: Holds:
        Objects (reference types).
        Variables allocated dynamically using new.
        Lifetime: Objects remain in memory until no references exist, at which point the GC removes them.
        Performance: Access is slower compared to the stack due to the need for reference dereferencing.
        Size: Heap size is larger and can grow dynamically based on the application's requirements.

        void Example() {
        string str = new string("Hello"); // Object allocated on the heap
        }

        Use stack for small, short-lived variables (e.g., method-local variables).
        Use heap for larger, more complex objects that need to persist beyond a single method scope.
    </p>
    <p> 6. What are Value types & Reference types?</p>
    <p>
        Value Types

        Value types hold data directly in memory. When a value type is assigned to another variable, a copy of the value is created. These types are stored on the stack.

        Examples of value types:
        Primitive types: int, double, float, char, bool
        Structs: DateTime, custom structs
        Enumerations: enum

        int a = 10;
        int b = a;  // 'b' is a copy of 'a'
        b = 20;

        Console.WriteLine(a);  // Output: 10
        Console.WriteLine(b);  // Output: 20
        In this example, modifying b does not affect a because a and b hold copies of the value.
        <br />

         
        Reference types hold a reference to the memory location where the data is stored, rather than the actual data itself. When a reference type is assigned to another variable, both variables refer to the same memory location. These types are stored on the heap.

        Examples of reference types:
        Classes: class
        Arrays: int[], string[]
        Delegates
        Strings (though immutable, it's a reference type)

        <br />

        class Person
        {
        public string Name;
        }

        Person person1 = new Person();
        person1.Name = "Alice";
        Person person2 = person1;  // 'person2' refers to the same object as 'person1'
        person2.Name = "Bob";

        Console.WriteLine(person1.Name);  // Output: Bob
        Console.WriteLine(person2.Name);  // Output: Bob


    </p>
    <p> 7. What are generic collections ?</p>
    <p>  In C#, generic collections are classes provided by the .NET framework that allow you to store and manipulate data in a type-safe manner. These collections allow you to specify the type of elements they store at compile-time, meaning the types are checked during compilation, ensuring type safety and reducing runtime errors.
Common Types of Generic Collections:

    List<T> – Represents a strongly typed list of objects.
    Dictionary<TKey, TValue> – Represents a collection of key/value pairs.
    Queue<T> – Represents a first-in, first-out (FIFO) collection of objects.
    Stack<T> – Represents a last-in, first-out (LIFO) collection of objects.
    HashSet<T> – Represents a collection of unique elements.
    </p>
    <p> 8. What are threads (Multithreading)? </p>
    <p>
        A thread is the smallest unit of execution in a program. It represents an individual path of execution, allowing multiple tasks to run concurrently. Threads enable multitasking, making programs more efficient by utilizing the CPU resources better.
        Key Concepts of Threads:

        Main Thread: The default thread that runs when a C# program starts. All tasks executed in the program run on this thread unless other threads are created.
        Thread Class: C# provides the System.Threading.Thread class to work with threads. This class allows creating, starting, and managing threads in your application.
        Thread Pool: The .NET runtime maintains a thread pool to handle multiple threads efficiently by reusing threads.

        Multithreading is the process of running multiple threads concurrently in a program.
        Each thread can perform a different task independently, leading to better resource utilization and faster performance
        in scenarios such as I/O operations or heavy computations.
        <pre><code>
        class Program
        {
        // Method to be run on a separate thread
        static void PrintNumbers()
        {
        for (int i = 1; i <= 5; i++)
        {
        Console.WriteLine(i);
        Thread.Sleep(1000);  // Simulating work by making the thread sleep for 1 second
        }
        }

        static void PrintAlphabets()
        {
        char letter = 'A';
        for (int i = 0; i < 5; i++)
        {
        Console.WriteLine(letter);
        letter++;
        Thread.Sleep(1000);  // Simulating work by making the thread sleep for 1 second
        }
        }

        static void Main(string[] args)
        {
        // Creating threads
        Thread thread1 = new Thread(PrintNumbers);
        Thread thread2 = new Thread(PrintAlphabets);

        // Starting the threads
        thread1.Start();
        thread2.Start();

        // Wait for both threads to complete
        thread1.Join();
        thread2.Join();

        Console.WriteLine("Both threads have completed their tasks.");
        }
        }
            </code></pre>

        The Start() method starts both threads concurrently.
        The Join() method is used to ensure that the main thread waits for both threads to complete their execution before printing the final message.
    </p>
    <p>
        9. Why do we need constructors ?
    </p>
    <p>
        A constructor allows you to set up an object with initial values at the time of its creation.
        Without a constructor, you would need to call separate methods or manually set each property after object creation, which can be less convenient and error-prone.
        Constructors can include logic to validate or process data before assigning it to the object's properties.
        This ensures that the object is always in a valid state upon creation.
        Constructors in C# can be overloaded to allow multiple ways to create an object with different levels of initialization.
        Static constructors initialize static members of a class. They are called automatically before the first use of the class and ensure class-level fields are set up properly.
        Constructors improve code clarity, maintainability, and safety by centralizing initialization logic and ensuring objects are always in a consistent state.
    </p>
    <p>
        10. Can we do Multiple inheritance with Abstract classes ?
    </p>
    <p>
        Multiple inheritance is not supported with classes (including abstract classes).
        This limitation is intentional to avoid the diamond problem and to simplify the complexity of the language's inheritance model.

        Instead of supporting multiple inheritance, C# allows a class to implement multiple interfaces, which achieves similar flexibility
        without the ambiguities of multiple inheritance.

        Why Multiple Inheritance with Abstract Classes is Not Supported

        Ambiguity in Inheritance: If two parent classes define methods or properties with the same name, it becomes unclear which method or property should take precedence in the derived class.

        Diamond Problem: In cases where a class inherits from two classes that themselves inherit from a common base class, it creates ambiguity about which version of the base class members to inherit.
    </p>
    <p> 11.  What is the need of Delegates ?</p>
    <p>
        Delegates in C# are objects that represent references to methods with a specific parameter list and return type. They are essential because they allow methods to be passed as parameters, enabling more flexible and dynamic code.

        ### Why do we need delegates?

        1. **Encapsulation of Method References**: They allow you to pass methods as parameters, which enables high levels of abstraction and flexibility.
        2. **Event Handling**: In C#, delegates are used for defining events and callback methods. They help decouple the event sender and the event handler, making it easier to add or remove event listeners dynamically.
        3. **Multithreading**: Delegates can be used to invoke methods asynchronously (using `BeginInvoke`/`EndInvoke` or the newer `Task` approach), which is useful for multithreading and non-blocking calls.

        ### Example: Real-Time Scenario (Event Handling)

        Consider a scenario where you are building a notification system, and you want to notify multiple systems or users when a new user signs up. Instead of directly calling each notification method in your `SignUp` method, you can use delegates and events.

        <pre><code>
        using System;

namespace DelegateExample {
  // Define a delegate type for notification methods
  public delegate void NotifyUser(string message);

  // Class that raises an event (Publisher)
  public class UserSignUp {
    public event NotifyUser OnUserSignUp; // Event using the delegate

    public void SignUp(string userName) {
      Console.WriteLine($"{userName} has signed up.");

      // Raise the event to notify all subscribers
      OnUserSignUp?.Invoke($"{userName} has successfully signed up!");
    }
  }

  // Class that handles the notification (Subscriber)
  public class NotificationService {
    public void SendEmail(string message) {
      Console.WriteLine($"Email Sent: {message}");
    }

    public void SendSMS(string message) {
      Console.WriteLine($"SMS Sent: {message}");
    }
  }

  class Program {
    static void Main(string[] args) {
      UserSignUp userSignUp = new UserSignUp();
      NotificationService notificationService = new NotificationService();

      // Subscribe to the event using delegates
      userSignUp.OnUserSignUp += notificationService.SendEmail;
      userSignUp.OnUserSignUp += notificationService.SendSMS;

      // Simulate user sign-up
      userSignUp.SignUp("John Doe");
    }
  }
}
        </code></pre>

        ### Explanation:
        - **Delegate**: `NotifyUser` is a delegate type that defines a method signature.
        - **Event**: The `UserSignUp` class declares an event `OnUserSignUp` of type `NotifyUser`. Events are based on delegates and are used to notify other components.
        - **Subscribing to Event**: In `Main`, we create a `NotificationService` instance and subscribe its methods `SendEmail` and `SendSMS` to the `OnUserSignUp` event.
        - **Raising Event**: When the `SignUp` method is called, it raises the event, notifying all subscribed methods (email and SMS in this case).

        ### Benefits:
        1. **Decoupling**: The `UserSignUp` class doesn't know how the notification will be sent. It simply raises the event, and the `NotificationService` handles it.
        2. **Extensibility**: If you want to add more notification methods (e.g., push notifications, in-app alerts), you just need to subscribe new methods to the `OnUserSignUp` event without modifying the `UserSignUp` class.

        ### Key Points:
        - Delegates help in making your code more flexible and reusable.
        - They are used in scenarios like event handling, callbacks, and implementing strategies.
    </p>
    <p>
       12. What are events ?
    </p>
    <p>
        In C#, **events** are a special type of **delegate** used to provide notifications when something happens in the application. Events are commonly used in the context of **publisher-subscriber** scenarios, where an object (the publisher) raises an event, and other objects (the subscribers) respond to that event.

        ### Key Characteristics of Events:
        1. **Encapsulation of Delegate**: An event is essentially a wrapper around a delegate. It allows the publisher to invoke the event, and the subscribers can handle it, but the publisher can control who can subscribe or unsubscribe.
        2. **Unidirectional**: Unlike a delegate, where you can both call and subscribe to methods, events allow only the publisher to raise the event, while subscribers can only listen for the event.
        3. **Multicast**: Events support multiple subscribers, so more than one method can handle the same event.

        ### Why are Events Used?
        - **Loose Coupling**: Events provide a way to decouple the logic between the publisher and the subscribers, making your code more modular and flexible.
        - **Asynchronous Notification**: In many scenarios, you want to notify multiple components of an action without tightly coupling them together. Events allow you to send notifications to all subscribers asynchronously.
        - **UI Event Handling**: In GUI frameworks like Windows Forms or WPF, events are used to handle user interactions such as button clicks, key presses, etc.

        ### Example: Simple Event Handling in C#

        <pre><code>
        using System;

        namespace EventExample
        {
        // Declare a delegate type
        public delegate void Notify(string message);

        // Publisher class
        public class Publisher
        {
        // Declare an event based on the delegate
        public event Notify OnNotification;

        // Method to trigger the event
        public void TriggerEvent(string message)
        {
        // Raise the event if there are any subscribers
        OnNotification?.Invoke(message);
        }
        }

        // Subscriber class
        public class Subscriber
        {
        public void HandleEvent(string message)
        {
        Console.WriteLine($"Event received: {message}");
        }
        }

        class Program
        {
        static void Main(string[] args)
        {
        // Instantiate the publisher and subscriber
        Publisher publisher = new Publisher();
        Subscriber subscriber = new Subscriber();

        // Subscribe to the event
        publisher.OnNotification += subscriber.HandleEvent;

        // Trigger the event
        publisher.TriggerEvent("Hello, this is a test event!");
        }
        }
        }
         </code></pre>

        ### Explanation:
        1. **Delegate**: `Notify` is a delegate type that defines the signature of the event handler methods.
        2. **Event**: The `Publisher` class declares an event `OnNotification` of type `Notify`. This event can be raised by the publisher and handled by any subscribed methods.
        3. **Subscriber**: The `Subscriber` class defines a method `HandleEvent` to handle the event when it is triggered.
        4. **Subscribing to the Event**: In the `Main` method, the subscriber subscribes to the `OnNotification` event of the publisher using the `+=` operator.
        5. **Raising the Event**: When `TriggerEvent` is called on the publisher, it raises the event by invoking the delegate, which calls the subscribed methods (`HandleEvent` in this case).

        ### Benefits of Events:
        1. **Encapsulation**: The publisher can raise events but cannot directly invoke the subscribed methods, making it safer and preventing accidental invocation.
        2. **Multicast**: You can have multiple subscribers to the same event, allowing different methods to handle the event in parallel.
        3. **Loose Coupling**: The publisher does not need to know anything about the subscribers. It only raises the event, and any object can handle it by subscribing.

        ### Real-World Example: UI Events
        In a GUI application, a button might have a click event. The button doesn't know what action will happen when it is clicked; it just triggers the `Click` event. Multiple components (subscribers) might be interested in handling that event (e.g., displaying a message, updating a UI element, or saving data). Events allow this dynamic behavior without tightly coupling the button to the specific actions.

        ### Summary:
        - **Events** are a way of providing notifications from a publisher to subscribers.
        - **Events** are based on **delegates** but offer a more controlled way of subscribing and unsubscribing.
        - Events are useful for **asynchronous notifications**, **UI interaction**, and **loose coupling** between components in your applications.
    </p>
    <p>
        13. Delegate VS Events.
    </p>
    <p>
        In C#, **delegates** and **events** are both used to handle callbacks or notifications, but they have key differences in their purpose and usage.

        ### **Delegate**
        A **delegate** is a type that defines a method signature. It can be used to reference methods with a matching signature and can be invoked like a regular method. Delegates are primarily used to implement event-driven programming but can be used on their own as well.

        **Example of Delegate:**
        <pre><code>
        using System;

        public class Program
        {
        // Define a delegate type
        public delegate void GreetDelegate(string name);

        public static void Main(string[] args)
        {
        // Create an instance of the delegate
        GreetDelegate greet = new GreetDelegate(Greet);

        // Invoke the delegate
        greet("John");
        }

        // Method to match delegate signature
        public static void Greet(string name)
        {
        Console.WriteLine($"Hello, {name}!");
        }
        }
         </code></pre>
        **Output:**
        ```
        Hello, John!
        ```

        ### **Event**
        An **event** is a special kind of delegate used primarily for signaling state changes or user interactions in an object-oriented way. An event is tied to a specific delegate type and provides a controlled mechanism to handle subscriptions and unsubscriptions.

        - Events restrict direct invocation from outside the class (only the class itself can raise the event).
        - Event handlers can be added or removed using the `+=` and `-=` operators.

        **Example of Event:**
        <pre><code>
        using System;

        public class Program
        {
        // Define a delegate type for the event
        public delegate void NotifyDelegate(string message);

        // Declare the event
        public static event NotifyDelegate Notify;

        public static void Main(string[] args)
        {
        // Subscribe to the event
        Notify += DisplayMessage;

        // Trigger the event
        OnNotify("Event triggered!");

        // Unsubscribe from the event
        Notify -= DisplayMessage;
        }

        // Method to raise the event
        public static void OnNotify(string message)
        {
        Notify?.Invoke(message);
        }

        // Event handler method
        public static void DisplayMessage(string message)
        {
        Console.WriteLine(message);
        }
        }
          </code></pre>
        **Output:**
        ```
        Event triggered!
        ```

        ### Key Differences:
        1. **Delegates**:
        - Can be used directly to assign methods or pass methods around.
        - Can be invoked directly.

        2. **Events**:
        - Are a special case of delegates used to represent notifications.
        - Cannot be invoked from outside the class where they are defined (except from within the class itself).
        - Provides built-in methods for adding/removing event handlers (`+=` and `-=`).

        In summary, **delegates** provide the underlying mechanism for calling methods indirectly, while **events** provide a controlled way to notify subscribers when something happens.
    </p>
    <p>
        14. What are the different types of "USING/HAS A" relationship ?
    </p>
    <p>
        In C#, the "USING/HAS A" relationship typically refers to the concept of object composition, where one class has or uses another class as part of its implementation. This type of relationship is often expressed through **composition** or **aggregation**. Here are the different types:

        ### 1. **Composition (Strong "HAS A" relationship)**
        - **Composition** represents a "strong" relationship where one object "owns" another, meaning if the containing object is destroyed, the contained object is also destroyed.
        - This is usually implemented by having a class as a member of another class, and the lifecycle of the member is managed by the containing class.

        **Example:**
        <pre><code>
        class Engine
        {
        public void Start()
        {
        Console.WriteLine("Engine starting...");
        }
        }

        class Car
        {
        private Engine engine;

        public Car()
        {
        engine = new Engine(); // Car "HAS A" Engine (Composition)
        }

        public void StartCar()
        {
        engine.Start();
        Console.WriteLine("Car is now running.");
        }
        }

        class Program
        {
        static void Main()
        {
        Car myCar = new Car();
        myCar.StartCar();  // Output: Engine starting... Car is now running.
        }
        }
          </code></pre>

        In this example, the `Car` class "HAS A" `Engine`. The `Engine` is created inside the `Car` class, and it will be destroyed when the `Car` object is destroyed.

        ---

        ### 2. **Aggregation (Weaker "HAS A" relationship)**
        - **Aggregation** is a "weaker" form of the "HAS A" relationship. The contained object can exist independently of the containing object. It signifies a "has-a" relationship but does not imply ownership or lifecycle management.
        - The contained object can be shared between other objects.

        **Example:**
        <pre><code>
        class Wheel
        {
        public void Rotate()
        {
        Console.WriteLine("Wheel rotating...");
        }
        }

        class Car
        {
        private Wheel wheel;

        public Car(Wheel wheel)
        {
        this.wheel = wheel; // Car "HAS A" Wheel (Aggregation)
        }

        public void Drive()
        {
        wheel.Rotate();
        Console.WriteLine("Car is driving.");
        }
        }

        class Program
        {
        static void Main()
        {
        Wheel wheel = new Wheel(); // Wheel exists independently
        Car myCar = new Car(wheel); // Wheel is passed to Car (Aggregation)
        myCar.Drive();  // Output: Wheel rotating... Car is driving.
        }
        }
       </code></pre>

        In this example, `Wheel` exists independently of the `Car`. Multiple cars could share the same wheel, and the wheel’s lifecycle is not tied to the car's lifecycle.

        ---

        ### 3. **Dependency (Using "HAS A" in terms of behavior)**
        - **Dependency** refers to a situation where one object uses another to perform its tasks but does not "own" the other object. This is often described as a "using" relationship.
        - It's typically a less formal relationship than composition and aggregation, where one class may interact with another through methods but without strong ownership.

        **Example:**
        <pre><code>
        class Logger
        {
        public void Log(string message)
        {
        Console.WriteLine($"Log: {message}");
        }
        }

        class Car
        {
        private Logger logger;

        public Car(Logger logger)
        {
        this.logger = logger; // Car "USES" Logger
        }

        public void Drive()
        {
        logger.Log("Car is being driven.");
        Console.WriteLine("Car is driving.");
        }
        }

        class Program
        {
        static void Main()
        {
        Logger logger = new Logger();
        Car myCar = new Car(logger); // Logger is passed to Car (Dependency)
        myCar.Drive();  // Output: Log: Car is being driven. Car is driving.
        }
        }
        </code></pre>

        Here, the `Car` class "uses" the `Logger` class to log messages during driving. However, the `Car` does not own or manage the lifecycle of the `Logger`.

        ---

        ### Key Differences:
        - **Composition**: Strong ownership, lifecycle tied together.
        - **Aggregation**: Weaker ownership, the contained object exists independently.
        - **Dependency**: One class uses another, but without ownership or lifecycle management.

        Each type of relationship is suited to different scenarios based on how tightly or loosely the objects are connected in terms of ownership, lifecycle, and functionality.
    </p>
    <p>
        15. Garbage Collector (GC)
    </p>
    <p>
        The **Garbage Collector (GC)** in .NET runs automatically as part of the .NET runtime (CLR - Common Language Runtime), and its execution is managed by the runtime itself, not explicitly by the developer. Here's how it operates and who executes it:

        ### 1. **Automatic Invocation by the CLR**:
        - The GC is an integral part of the **Common Language Runtime (CLR)**, which is the execution engine of .NET applications. When you run a .NET application, the CLR is responsible for handling the execution of the code, including memory management.
        - The GC is invoked by the CLR automatically during the program's execution, usually when it detects memory pressure (e.g., low memory), when the application allocates more objects, or when certain thresholds are reached in memory usage.
        - **Program Execution Flow**: As your program runs, it makes requests for memory to the heap. The GC is responsible for cleaning up the memory once objects become unreachable, and the CLR decides when to run the GC based on factors like heap size and memory usage.

        ### 2. **GC Triggers**:
        The CLR decides when to invoke the GC based on the following conditions:
        - **Memory Allocation Thresholds**: When a large number of objects are allocated, or the heap becomes full, the CLR may trigger a GC cycle.
        - **Low Memory**: If the system is running low on memory, the GC may be triggered to free up space.
        - **Manual Invocation**: Developers can call `GC.Collect()` explicitly, but this is generally discouraged as it can interfere with the automatic garbage collection process.

        ### 3. **Execution Process**:
        - **GC Threads**: The GC operates on a **separate thread** from the application's main execution threads. This means the GC runs in the background while your application executes. The GC can run concurrently with the application code (though it may stop execution for short periods during collection).
        - **Thread Synchronization**: In a multithreaded application, the GC may synchronize with application threads to ensure that no objects are accessed while they are being collected. During a **GC pause**, all application threads are temporarily suspended, ensuring that objects are not modified during collection.

        ### 4. **Generations**:
        - As discussed earlier, the GC works in **generations**, which optimizes the collection process by focusing on younger generations more often. The CLR decides when to perform a collection based on which generation has accumulated objects.
        - **Gen 0** (young objects) is collected most frequently, while **Gen 1** and **Gen 2** are collected less frequently.

        ### 5. **Types of GC Operations**:
        There are several types of GC operations:
        - **Full GC**: This occurs when a collection is triggered for all generations (0, 1, and 2). It’s more costly and is typically triggered when a large amount of memory needs to be reclaimed.
        - **Minor GC**: This occurs for just Generation 0 objects. Minor GC is relatively quicker since it only deals with young objects.
        - **Concurrent GC**: In some cases, the GC can run concurrently with the application’s threads, particularly in .NET Core or .NET 5+ with features that allow background GC (to reduce pause times).

        ### 6. **Finalization and Cleanup**:
        - If an object has a **finalizer** (a method called before the object is destroyed), the GC will handle this during the collection process. Finalizers are queued for execution before the object’s memory is freed, but the timing is non-deterministic.
        - After an object’s finalizer is executed, the object is marked for cleanup and memory is reclaimed.

        ### 7. **Who Executes the GC?**
        - **CLR and GC Thread**: The GC is executed by the CLR, specifically by a background **GC thread**. This is done automatically as part of the .NET runtime's internal mechanisms. Developers don't have to explicitly start or manage the GC process.
        - **Managed by the Runtime**: The CLR (or .NET Runtime in newer versions) manages the GC lifecycle, so developers don’t need to worry about memory management details. However, understanding how the GC works can help improve application performance (e.g., by minimizing unnecessary object allocations and avoiding manual GC invocation unless necessary).

        ### 8. **GC Execution in Different .NET Versions**:
        - **.NET Framework**: The GC runs in the background, typically using a **stop-the-world** approach, where application threads are paused during collection.
        - **.NET Core and .NET 5+**: In newer .NET versions, the GC has been improved to be more **concurrent**, minimizing pause times and allowing garbage collection to happen while the application continues running. This provides better performance for applications with high throughput or low-latency requirements.

        ### Summary:
        - The **Garbage Collector (GC)** is part of the **CLR** and is automatically executed by the runtime to manage memory.
        - It runs in the background on a **separate thread** from the main application threads and is triggered based on memory pressure, allocations, or other conditions.
        - The CLR manages the process, so developers don't need to manually invoke the GC except in special cases (e.g., calling `GC.Collect()`).
        - The GC works efficiently through **generational collection** to minimize pauses and optimize memory management for .NET applications.
    </p>
    <p>
        The **Garbage Collector (GC)** in .NET is an automatic memory management system that is responsible for reclaiming memory occupied by objects that are no longer in use by the application. This process helps prevent memory leaks by ensuring that unused objects are cleaned up, freeing memory for new allocations. Here's a deeper look into how it works:

        ### Key Concepts of Garbage Collection

        1. **Automatic Memory Management**:
        The GC is designed to handle memory management automatically, so developers do not have to manually allocate and deallocate memory (like in languages such as C or C++). This helps in reducing errors like memory leaks and dangling pointers.

        2. **Heap and Stack**:
        - **Heap**: This is the area of memory used for dynamic memory allocation where objects are created. The garbage collector manages memory in the heap.
        - **Stack**: This is used for storing method calls and local variables. The stack is managed automatically by the runtime and does not require garbage collection.

        3. **Reference Counting and Reachability**:
        The GC tracks the references to objects in memory. If an object is no longer referenced (i.e., there are no active pointers or references to it), the object is considered unreachable and eligible for garbage collection.

        ### How the Garbage Collector Works

        1. **Marking Phase**:
        - The GC starts by identifying which objects are still in use. It begins with "root" objects, such as static variables, local variables in method calls, and CPU registers.
        - From these roots, it traces all objects that are reachable (objects directly or indirectly referenced). These are marked as "alive."

        2. **Sweeping Phase**:
        - After the marking phase, all the unreachable (unreferenced) objects are considered for cleanup. These objects are removed from memory to free up space.

        3. **Compaction Phase**:
        - To avoid fragmentation of memory, the GC may compact the heap after collecting garbage. This involves moving the surviving objects together, reducing gaps between them, so there’s a contiguous block of free memory for new allocations.

        This step is more expensive in terms of time but improves memory management in the long term.

        ### Generational Garbage Collection

        .NET's GC uses a **generational model** to optimize the collection process. Objects are organized into three generations:
        - **Generation 0**: Newly allocated objects. Most objects die young, so Generation 0 is collected more frequently.
        - **Generation 1**: Objects that survived one or more garbage collections from Generation 0. These are less likely to become unreachable quickly.
        - **Generation 2**: Long-lived objects, often those that survive several collections. The GC collects Generation 2 less frequently, as these objects are assumed to be in use for longer periods.

        This generational approach helps improve performance because collecting older generations is more expensive, and objects that survive longer tend to be less likely to become unreachable.

        ### Finalization and IDisposable

        - **Finalization**: Objects can have a `Finalize` method (also called a destructor in C#) to clean up unmanaged resources before the object is reclaimed by the GC. This method is called by the GC before the object’s memory is freed.
        - However, finalization is not guaranteed to occur immediately, which can lead to delayed cleanup of resources.

        - **IDisposable Interface**: For objects that use unmanaged resources (e.g., file handles, database connections), .NET provides the `IDisposable` interface, which defines a `Dispose` method. Developers can manually call `Dispose()` to release unmanaged resources, rather than relying on finalization.

        ### GC and Performance

        - **Non-Deterministic**: The garbage collector runs asynchronously and is non-deterministic, meaning you cannot predict exactly when it will occur. The timing depends on memory usage and the GC’s internal decisions.
        - **GC.Collect()**: While garbage collection usually runs automatically, developers can explicitly trigger it using `GC.Collect()`. However, this is generally discouraged because manual GC collection may harm performance if done excessively. It is better to let the GC run on its own.

        ### Summary

        The **Garbage Collector (GC)** is an essential part of the .NET runtime that automatically manages memory by identifying and reclaiming memory occupied by objects that are no longer in use. It works in a generational manner to optimize performance, and it helps prevent memory leaks by handling both managed and unmanaged resources efficiently. However, developers still need to be cautious with unmanaged resources by implementing the `IDisposable` pattern and using `Dispose()` appropriately.
    </p>
    <p>

    </p>
</body>
</html>